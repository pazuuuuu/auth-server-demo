<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Auth Server</title>
    <link rel="stylesheet" th:href="@{/css/style.css}">
    <meta name="_csrf" th:content="${_csrf.token}" />
    <meta name="_csrf_header" th:content="${_csrf.headerName}" />
</head>

<body>
    <div class="login-container">
        <div class="login-header">
            <h2>Welcome</h2>
            <p>You are successfully logged in.</p>
        </div>
        <div style="text-align: center;">
            <p>This is the Authorization Server.</p>
            <button onclick="registerPasskey()" class="btn btn-primary" style="margin-top: 20px;">Register
                Passkey</button>
            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                You can register multiple passkeys for different devices (e.g., Touch ID, Face ID).
            </p>
            <div id="message" style="margin-top: 10px;"></div>
        </div>
    </div>

    <script>
        async function registerPasskey() {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = "Starting registration...";
            messageDiv.style.color = "black";

            try {
                // 1. Get creation options
                const optionsResponse = await fetch('/webauthn/register/options', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': getCsrfToken() // Need CSRF token if enabled
                    }
                });

                if (!optionsResponse.ok) {
                    throw new Error('Failed to get options');
                }

                const publicKeyCredentialCreationOptions = await optionsResponse.json();

                // Decode base64url fields
                publicKeyCredentialCreationOptions.challenge = base64UrlToBuffer(publicKeyCredentialCreationOptions.challenge);
                publicKeyCredentialCreationOptions.user.id = base64UrlToBuffer(publicKeyCredentialCreationOptions.user.id);
                if (publicKeyCredentialCreationOptions.excludeCredentials) {
                    publicKeyCredentialCreationOptions.excludeCredentials.forEach(cred => {
                        cred.id = base64UrlToBuffer(cred.id);
                    });
                }

                // 2. Create credential
                const credential = await navigator.credentials.create({
                    publicKey: publicKeyCredentialCreationOptions
                });

                // 3. Send to server
                const response = await fetch('/webauthn/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': getCsrfToken()
                    },
                    body: JSON.stringify({
                        publicKey: {
                            credential: {
                                id: credential.id,
                                rawId: bufferToBase64Url(credential.rawId),
                                type: credential.type,
                                response: {
                                    attestationObject: bufferToBase64Url(credential.response.attestationObject),
                                    clientDataJSON: bufferToBase64Url(credential.response.clientDataJSON)
                                },
                                clientExtensionResults: credential.getClientExtensionResults()
                            },
                            label: "Passkey (" + new Date().toISOString() + ")"
                        }
                    })
                });

                if (response.ok) {
                    messageDiv.textContent = "Passkey registered successfully!";
                    messageDiv.style.color = "green";
                } else {
                    messageDiv.textContent = "Registration failed.";
                    messageDiv.style.color = "red";
                }
            } catch (e) {
                console.error(e);
                messageDiv.textContent = "Error: " + e.message;
                messageDiv.style.color = "red";
            }
        }

        function base64UrlToBuffer(base64url) {
            const padding = '='.repeat((4 - base64url.length % 4) % 4);
            const base64 = (base64url + padding)
                .replace(/\-/g, '+')
                .replace(/_/g, '/');
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray.buffer;
        }

        function bufferToBase64Url(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary)
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        function getCsrfToken() {
            // In Thymeleaf, we can get it from meta tags if we add them, 
            // or we might need to disable CSRF for this endpoint if we are lazy.
            // But let's try to be secure.
            // I'll add meta tags to the head.
            return document.querySelector('meta[name="_csrf"]')?.content;
        }
    </script>
</body>

</html>